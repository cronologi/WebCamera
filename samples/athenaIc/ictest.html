<!DOCTYPE html>
<html>
<head>
<style>
.outerImageContainer { margin: 20px;}
.innerImageContainer { width: 100%; height: 100%; position: relative; }
.coveredImage { width: 100%; height: 100%; position: absolute; top: 0px; left: 0px;}
.coveringCanvas { width: 100%; height: 100%; position: absolute; top: 0px; left: 0px; pointer-events: none;}
</style>
</head>

<body>
<h1>getUserMedia Test</h1>

<h2>video</h2>
<div id="div_outer" class="outerImageContainer" style="width:640px;height:480px;">
<div id="div_inner" class="innerImageContainer">
<p><video class="coveredImage" width="640" height="480" controls playsinline autoplay></video></p>
<p><canvas class="coveringCanvas" style="z-index: 999;" width="640" height="480"></canvas></p>
</div>
</div>

<h2>metadata</h2>
<p><pre id="info_metadata">-</pre></p>

<h2>properties</h2>
<p><pre id="info_properties">-</pre></p>

<h2>settings</h2>
<p><pre id="info_settings">-</pre></p>

<h2>mediaDevices.getSupportedConstraints</h2>
<p><pre id="info_constraints">-</pre></p>

<h2>videoTrack.getCapabilities()</h2>
<p><pre id="info_capabilities">-</pre></p>

<h2>errors</h2>
<p><pre id="info_errors">-</pre></p>

<script>

const startDrawing = () => { 
  const video = document.querySelector("video");
  const canvas = document.querySelector("canvas");
  const ctx = canvas.getContext("2d");
  const info_metadata = document.querySelector("#info_metadata");
  const info_properties = document.querySelector("#info_properties");
  const info_settings = document.querySelector("#info_settings");
  const info_constraints = document.querySelector("#info_constraints");
  const info_capabilities = document.querySelector("#info_capabilities");

  const supportedConstraints = navigator.mediaDevices.getSupportedConstraints();        // getSupportedConstraints
  info_constraints.innerText = JSON.stringify(supportedConstraints, null, 2);

  let videoTracks = null;
  const constraints = {
    video: {
      backgroundBlur: true,
      faceFraming: true,
      lightingCorrection: true,
    },
  };

  navigator.mediaDevices.getUserMedia(constraints).then((stream) => {                   // getUserMedia
    video.srcObject = stream;
    videoTracks = stream.getVideoTracks();
    if (videoTracks.length) {
      videoTrack = videoTracks[0];
    }
    const capabilities = videoTrack.getCapabilities();                                  // getCapabilities
    info_capabilities.innerText = JSON.stringify(capabilities, null, 2);

    const settings = videoTrack.getSettings();                                          // getSettings
    info_settings.innerText = JSON.stringify(settings, null, 2);
  }).catch((error) => {
    info_errors.innerText = info_errors.innerText + ',' + JSON.stringify(error, null, 2);
  });

  video.addEventListener('play', () => {
    if (!('requestVideoFrameCallback' in HTMLVideoElement.prototype)) {
      info_errors.innerText = info_errors.innerText + ',requestVideoFrameCallback API not supported';
    }
  });
  
  const width = canvas.width;
  const height = canvas.height;

  const updateCanvas = (now, metadata) => {
    info_metadata.innerText = JSON.stringify(metadata, null, 2);

    videoTrack.getProperties().then((properties) => {                                   // getProperties
      info_properties.innerText = JSON.stringify(properties, null, 2);
      // Draw detected faces onto canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const faces = properties.detectedFaces;
      ctx.beginPath();
      ctx.strokeStyle = "#FF0000";
      for (let face of faces) {
         ctx.rect(face.boundingBox.x, face.boundingBox.y, face.boundingBox.width, face.boundingBox.height);
      }
      ctx.stroke();
    });

    video.requestVideoFrameCallback(updateCanvas);
  };  

  video.requestVideoFrameCallback(updateCanvas);  
};

window.addEventListener('load', startDrawing);

</script>
</body>
</html>
